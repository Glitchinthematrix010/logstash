filter {
  if ( [type] == "syslog" or [type] == "cee" and [syslog][identifier] =~ /\(\"U7LT,[0-9a-f]+,v[0-9.]+\"\)/ ) or [type]== "wifi" {
    mutate {
      add_field => { "application" => "Ubiquiti" }
      replace => { "type" => "wifi" }
    }
    if [message] =~ /^hostapd: / {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_tag => [ "Known Message", "Error" ]
        match => { "message" => [
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} IEEE 802\.11: did not acknowledge authentication response$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} IEEE 802\.11: disconnected due to excessive missing ACKs$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} WPA: received EAPOL-Key with invalid MIC$",
          "^hostapd: \[\s*\d+\.\d+\] \[%{INTF_DST}\] FWLOG: \[\d+\] WHAL_ERROR_RESET_CHANNF1 \(  \)$",
          "^hostapd: \[\s*\d+\.\d+\] ar9300_handle_radar_bb_panic: BB status=0x04008009 rifs=1 - disable$",
          "^hostapd: process '/bin/stamgr -i 1 ' \(pid %{POSINT:[syslog][pid]}\) exited\. Scheduling for restart\.$"
        ] }
      }
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_tag => [ "Known Message", "Benign" ]
        match => { "message" => [
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} IEEE 802\.11: (sta_stats|disassociated)$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} IEEE 802\.11: associated( \(aid \d+\))?$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} IEEE 802\.11: authenticated$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} IEEE 802\.11: deauthenticated due to (local deauth request|inactivity \(timer DEAUTH/REMOVE\))$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} IEEE 802\.11: disassociated due to inactivity$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} RADIUS: starting accounting session [0-9A-F-]+$",
          "^hostapd: %{INTF_DST}: STA %{MAC_SRC} WPA: (pairwise|group) key handshake completed \(RSN\)$",
          "^hostapd: Child connection from %{IP_SRC}:%{PORT_SRC}$",
          "^hostapd: reloading /etc/inittab$",
          "^hostapd: starting pid %{POSINT:[syslog][pid]}, tty '/dev/null': '/bin/stamgr -i 1 '$"
        ] }
      }
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_field => { "[host][src][wifi-state]" => "Associated" }
        match => { "message" => [ 
          "^hostapd: %{INTERFACENAME}: STA %{MAC} IEEE 802\.11: associated( \(aid \d+\))?$"
        ] }
      }
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_field => { "[host][src][wifi-state]" => "Disassociated" }
        match => { "message" => [ 
          "^hostapd: %{INTERFACENAME}: STA %{MAC} IEEE 802\.11: disassociated( due to inactivity)?$"
        ] }
      }
    } else if [message] =~ /^kernel: / {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_tag => [ "Known Message", "Error" ]
        match => { "message" => [
          "^kernel: \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+FIRMWARE:ATF PEER REQ: NUM-PEERS: \d+$",
          "^kernel: \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+\[%{INTF_DST}\] FWLOG: \[\d+\] WAL_DBGID_SECURITY_UCAST_KEY_SET \( %{BASE16NUM} \)$",
          "^kernel: \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+\[%{INTF_DST}\] FWLOG: \[\d+\] WAL_DBGID_STA_KICKOUT \( %{BASE16NUM} \)$",
          "^kernel: \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+\[%{INTF_DST}\] FWLOG: \[\d+\] WAL_DBGID_STA_VDEV_XRETRY \( %{BASE16NUM}, %{BASE16NUM}, %{BASE16NUM}, %{BASE16NUM} \)$",
          "^kernel: \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+\[%{INTF_DST}\] FWLOG: \[\d+\] WAL_DBGID_TX_BA_SETUP \( %{BASE16NUM}, %{BASE16NUM}, %{BASE16NUM}, %{BASE16NUM}, %{BASE16NUM} \)$",
          "^kernel: \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+ath_tx_sched_aggr: Recovering from error condition: Flushing TID queue until head\s+is within the window$",
          "^kernel: \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+wmi_unified_event_rx : no registered event handler : event id %{BASE16NUM}",
          "^kernel: \[\s*\d+\.\d+\] STOPPED EVENT for vap \d+ \(%{BASE16NUM}\)$",
          "^kernel: \[\s*\d+\.\d+\] \[%{INTF_DST}\] FWLOG: \[\d+\] WHAL_ERROR_RESET_CHANNF1 \(  \)$",
          "^kernel: \[\s*\d+\.\d+\] \[%{INTF_DST}\] FWLOG: \[\d+\] vap-1 AP PS: AID=%{INT} detected out-of-sync now=%{INT} tx_waiting=%{INT} txq_depth=%{INT}$",
          "^kernel: \[\s*\d+\.\d+\] ar9300_abort_tx_dma\[\d+\]: ar9300_stop_dma_receive failed$",
          "^kernel: \[\s*\d+\.\d+\] ar9300_handle_radar_bb_panic: BB status=0x04008009 rifs=[01] - disable$",
          "^kernel: \[\s*\d+\.\d+\] ar9300_reset\[\d+\]: ar9300_stop_dma_receive failed$",
          "^kernel: \[\s*\d+\.\d+\] ath_tx_sched_aggr: Recovering from error condition: Flushing TID queue until head\s+is within the window$",
          "^kernel: \[\s*\d+\.\d+\] wmi_unified_event_rx : no registered event handler : event id 0x901b",
          "^kernel: \[\s*\d+\.\d+\]\s+Could not find the peer\s*$",
          "^kernel: \[\s*\d+\.\d+\]\s+Unable to process TX info\s*$",
          "^kernel: \[\s*\d+\.\d+\]\s+ieee80211_ioctl_kickmac\[%{INT}\]",
          "^kernel: \[truncated\] \[\s*\d+\.\d+\] (badsta\? \(atf descs %{MAC_SRC} \d+\) )+%{DATA}$"
        ] }
      }
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_tag => [ "Known Message", "Benign" ]
        match => { "message" => [
          "^kernel: \[\s*\d+\.\d+\] %{INTF_DST}: no IPv6 routers present$",
          "^kernel: \[\s*\d+\.\d+\] Atheros AR8216/AR8236/AR8316 ag71xx-mdio\.0:00: Port %{INT} is (up|down)$",
          "^kernel: \[\s*\d+\.\d+\] Enable ATF for DA         $",
          "^kernel: \[\s*\d+\.\d+\] FIRMWARE:ATF PEER REQ: NUM-PEERS: \d+$",
          "^kernel: \[\s*\d+\.\d+\] Notification to UMAC VAP layer$",
          "^kernel: \[\s*\d+\.\d+\] OL vap_(start|stop) [+-]$",
          "^kernel: \[\s*\d+\.\d+\] \[%{INTF_DST}\]( \[%INTERFACENAME}\])? FWLOG: \[\d+\] RATE: ChainMask [13], phymode 10444(84|86|89|90), ni_flags 0x(00003006|02003006|02013006|00221006|00223006|02003006|0222b006|0223b006|02233006), vht_mcs_set 0x(0000|00ff|fffa|fffe|ffff), ht_mcs_set 0x(00|ff)ff, legacy_rate_set %{BASE16NUM}$", 
          "^kernel: \[\s*\d+\.\d+\] \[%{INTF_DST}\]( \[%{INTERFACENAME}\])? FWLOG: \[\d+\] WAL_DBGID_.*",
          "^kernel: \[\s*\d+\.\d+\] ath_tx_sched_aggr: TID\[\d+\] seq_start:\d+ seq_next:\d+ Head:\d+ Tail:\d+ BAW size:\d+ seqno:\d+$",
          "^kernel: \[\s*\d+\.\d+\] br0: port \d+\(%{INTF_SRC}\) entered forwarding state         $",
          "^kernel: \[\s*\d+\.\d+\] ol_ath_vap_join: join operation is only for STA/IBSS mode$",
          "^kernel: \[\s*\d+\.\d+\] ol_ath_wmm_update:$",
          "^kernel: \[\s*\d+\.\d+\] ol_vdev_start_resp_ev for vap \d+ \(%{BASE16NUM}\)$",
          "^kernel: \[\s*\d+\.\d+\] ubnt_calc_airtime_average\[1382\] tick counter wrapped, time_delta:\d+          $",
          "^kernel: \[\s*\d+\.\d+\] wlan_get_active_vport_chan: ch=\d+          $",
          "^kernel: \[\s*\d+\.\d+\] wmi_unified_vdev_(start|stop|up)_send for vap \d+ \(%{BASE16NUM}\)$",
          "^kernel: \[\s*\d+\.\d+\]\s*$"
        ] }
      }
    } else if [message] =~ /^syslog: / {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_tag => [ "Known Message", "Error" ]
        match => { "message" => [
          "^syslog: Premature exit: Terminated by signal$",
          "^syslog: ace_reporter\.reporter_connected\(\): connect\(%{URI}\) failed with errors: %{DATA}$",
          "^syslog: ace_reporter\.reporter_fail\(\): Not Adopted \(%{URI}\)$",
          "^syslog: ace_reporter\.reporter_fail\(\): Unreachable \(%{URI}\)$",
          "^syslog: ace_reporter\.reporter_fail\(\): inform failed #%{INT} \(last inform: %{INT} seconds ago\), rc=3$",
          "^syslog: ace_reporter\.reporter_fail\(\): initial contact failed #\d+, url=%{URI}, rc=\d+$",
          "^syslog: ace_reporter\.reporter_next_inform_url\(\): next inform url\[\d+\]=%{URI}$",
          "^syslog: mca-ctrl.do_monitor\(\): \[event\] fatal radio error detected, resetting$",
          "^syslog: ubntevent\.update\(\): fatal chip error detected on wifi1$",
          "^syslog: wevent\.wevent_receive\(\): netlink: recvfrom failed: No buffer space available$"
        ] }
      }
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_tag => [ "Known Message", "Benign" ]
        match => { "message" => [
          "^syslog: ace_reporter\.reporter_fail\(\): \[STATE\] entering SELFRUN!!!!$",
          "^syslog: ace_reporter\.reporter_handle_response\(\): \[setparam\] applying new system.cfg$",
          "^syslog: ace_reporter\.reporter_handle_response\(\): cfgversion: %{BASE16NUM} -> %{BASE16NUM}$",
          "^syslog: ace_reporter\.reporter_set_managed\(\): \[STATE\] enter MANAGED$",
          "^syslog: wevent.ubnt_custom_event\(\): EVENT_STA_(JOIN|LEAVE) %{INTF_DST}: %{MAC_SRC} / \d+$"
        ] }
      }
    } else {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        tag_on_failure => [ ]
        add_tag => [ "Known Message", "Benign" ]
        match => { "message" => [
          "^dropbear\[%{POSINT:[syslog][pid]}\]: Child connection from %{IP_SRC}:%{PORT_SRC}$",
          "^dropbear\[%{POSINT:[syslog][pid]}\]: Exit before auth: Exited normally$",
          "^dropbear\[%{POSINT:[syslog][pid]}\]: Login attempt for nonexistent user from %{IP_SRC}:%{PORT_SRC}$",
          "^dropbear\[%{POSINT:[syslog][pid]}\]: Password auth succeeded for 'admin' from %{IP_SRC}:%{PORT_SRC}$",
          "^dropbear\[%{POSINT:[syslog][pid]}\]: Pubkey auth attempt with unknown algo for 'admin' from %{IP_SRC}:%{PORT_SRC}$",
          "^init: The system is going down NOW\!$",
          "^init: process '/sbin/ntpclient -i 86400 -n -s -c 0 -l -h 0\.ubnt\.pool\.ntp\.org' \(pid %{POSINT:[syslog][pid]}\) exited. Scheduling for restart\.$",
          "^init: reloading /etc/inittab$",
          "^init: starting pid %{POSINT:[syslog][pid]}, tty '': '/bin/umount -a -r'$",
          "^init: starting pid %{POSINT:[syslog][pid]}, tty '': '/etc/rc.d/rc ministop'$",
          "^init: starting pid %{POSINT:[syslog][pid]}, tty '/dev/null': '/sbin/ntpclient -i 86400 -n -s -c 0 -l -h 0\.ubnt\.pool\.ntp\.org'$",
          "^syswrapper: \[busy\] skipping: reload$",
          "^syswrapper: \[state is locked\] skipping reload$",
          "^syswrapper: ipready\.br0 = %{IP_DST}$"
        ] }
      }
    }
  }
}
