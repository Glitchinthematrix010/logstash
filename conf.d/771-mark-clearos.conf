filter {
  if [received_from] =~ /^firewall/ or [received_from] == "10.0.0.1" or [received_from] == "127.0.0.1" {
    mutate {
      add_field => { "application" => "ClearOS" }
    }
    if [syslog][identifier] == "CROND" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^\(root\) CMD \(/usr/clearos/apps/configuration_backup/deploy/backup-now >/dev/null 2>&1\)$",
          "^\(root\) CMD \(/usr/sbin/(network|proxy|resource)2db >/dev/null 2>&1\)$",
          "^\(root\) CMD \(/usr/sbin/(philesight-updatedb|purge-proxy) >/dev/null 2>&1\)$",
          "^\(root\) CMD \(/usr/sbin/timesync\)$",
          "^\(root\) CMD \(LANG=en_US /usr/clearos/apps/base/deploy/servicewatch >/dev/null\)$"
        ] }
      }
    } else if [syslog][identifier] == "NET" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "/sbin/dhclient-script : updated /etc/resolv-peerdns\.conf$"
        ] }
      }
    } else if [syslog][identifier] =~ /^app-/ {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^Dynamic DNS update not required on %{IP_DST}$"
        ] }
      }
    } else if [syslog][identifier] == "^clearos-ecap-adapter$" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^virtual std::string Adapter::Service::uri\(\) const$",
          "^virtual void Adapter::Service::start\(\)$",
          "^virtual void ConfigParser::ParseElementClose\(ExpatXmlTag\*\): clearos-ecap-adapter$",
          "^virtual void ConfigParser::ParseElementClose\(ExpatXmlTag\*\): header$",
          "^virtual void ConfigParser::ParseElementOpen\(ExpatXmlTag\*\): clearos-ecap-adapter$",
          "^virtual void ConfigParser::ParseElementOpen\(ExpatXmlTag\*\): header$",
          "^void Adapter::Service::addHeader\(std::string&, std::string&\): X-YouTube-Edu-Filter: abcdefghijklmnopqrstuv$",
          "^void Adapter::Service::addHeader\(std::string&, std::string&\): X-YouTube-Edu-Filter: abcdefghijklmnopqrstuv$"
        ] }
      }
    } else if [syslog][identifier] =~ "^clearsyncd?$" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^base - checking system database$",
          "^base - event triggered - ulimit_workaround$",
          "^base - event triggered - webconfig_change_event$",
          "^base - restarting web proxy for ulimit update$",
          "^base - restarting webconfig$",
          "^base - webconfig restart requested$",
          "^ClearSync initialized\.$"
        ] }
      }
    } else if [syslog][identifier] == "crond" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^%{CO_CRONACTIONS} %{CO_CRONJOBS}$"
        ] }
      }
    } else if [syslog][identifier] == "ddclient" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^WARNING:  forcing update of %{HOST_DST} from %{IPV4} to %{IP_DST}; 25 days since last update on Mon Aug 15 00:45:30 2016.$",
          "^SUCCESS:  updating %{HOST_DST}: good: IP address set to %{IP_DST}$"
        ] }
      }
    } else if [syslog][identifier] == "dhclient" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^DHCPACK from %{IP_SRC} \(xid=0x%{BASE16NUM}\)$",
          "^DHCPDISCOVER on %{INTF_DST} to 255\.255\.255\.255 port %{PORT_DST} interval %{INT} \(xid=%{BASE16NUM}\)$",
          "^DHCPNAK from %{IP_SRC} \(xid=%{BASE16NUM}\)$",
          "^DHCPOFFER from %{IP_SRC}$",
          "^DHCPREQUEST on %{INTF_SRC} to %{IP_DST} port 67 \(xid=0x%{BASE16NUM}\)$",
          "^No DHCPOFFERS received\.$",
          "^Trying recorded lease %{IP_DST}$",
          "^bound to %{IP_DST} -- renewal in %{POSINT} seconds\.$"
        ] }
      }
    } else if [syslog][identifier] == "dnsmasq" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "reading \/etc\/resolv-peerdns\.conf$"
        ] }
      }
    } else if [syslog][identifier] =~ /[a-zA-Z]+2db$/ {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^Unable to create lock file: Server is running low on available disk space - preventing further modifications via API until disk space issues are resolved\.\.$",
          "^Processed %{POSINT} proxy log lines - %{POSINT} records added\.$"
        ] }
      }
    } else if [syslog][identifier] == "engine" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Error" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^exception: debug backtrace: %{DATA}$",
          "^exception: error: /usr/clearos/apps/base/libraries/Shell.php \(207\): %{MONTHDAY} %{MONTH} %{HOUR}:%{MINUTE}:%{SECOND} ntpdate\[\d+\]: no server suitable for synchronization found$"
        ] }
      }
    } else if [syslog][identifier] == "events" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^network_connected - event occurred$",
          "^network_connected - triggered hook: (date|intrusion_detection|network)$",
          "^network_peerdns - event occurred$",
          "^network_peerdns - triggered hook: (network_resolver|openvpn)$"
        ] }
      }
    } else if [syslog][identifier] == "firewall" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^# Config file$",
          "^# This script is run after every firewall restart.  Add custom rules here.$",
          "^Content filter is offline$",
          "^Defining custom chains$",
          "^Detected (Backup )?[LW]AN info - %{INTF_DST} %{IP_DST} on network %{IPV4}/%{POSINT}$",
          "^Detected [LW]AN (backup )?role for interface: %{INTF_DST}$",
          "^Disabling NAT - no active WANS$",
          "^Enabled proxy transparent mode$",
          "^Enabling NAT on WAN interface %{INTF_DST}$",
          "^Execution time: %{BASE10NUM}%{TIMEUNITS}$",
          "^Loading (environment|kernel modules( for NAT)?)$",
          "^Port forwarding (tcp|udp|sctp) %{POSINT}(:%{POSINT})? to %{IP_DST}( %{POSINT})?$",
          "^Running (1-to-1 NAT|blocked external|common|custom|default forwarding|default incoming allowed|incoming denied|user-defined (incoming|outgoing block|port forward|proxy)) rules$",
          "^Running /etc/clearos/firewall\.d/(10-intrusion-prevention|custom|local)$",
          "^Running multipath$",
          "^Running post-firewall 10670$",
          "^Setting (default policy to DROP|kernel parameters)$",
          "^Skipping 1-to-1 NAT rules - no active WAN interfaces$",
          "^Starting firewall\.\.\.$",
          "^Using gateway mode$",
          "^WARNING: No configured WAN interfaces, continuing anyway\.\.\.$",
          "^Warning: WAN device has no IP address: %{INTF_DST}$",
          "^Web proxy is o(ff|n)line$",
          "^iptables -[AIN] %{DATA}$"
        ] }
      }
    } else if [syslog][identifier] == "intrusion-detection" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^Network configuration was updated\.$",
          "^restarting intrusion detection$"
        ] }
      }
    } else if [syslog][identifier] == "network" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^Bringing up loopback interface:  \[  OK  \]$"
        ] }
      }
    } else if [syslog][identifier] == "openvpn" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Error" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^Options error: --\(ca|cert|key\) fails with '/etc/pki/CA/\(ca|sys-0|private/sys-0\)-cert\.pem': No such file or directory$",
          "^Options error: Please correct these errors\.$",
          "^Use --help for more information\.$"
        ] }
      }
    } else if [syslog][identifier] =~ /^run-parts\(\/etc\/cron\.(daily|hourly|weekly|monthly)\)$/ {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "%{CO_CRONACTIONS} %{CO_CRONJOBS}$"
        ] }
      }
    } else if [syslog][identifier] == "servicewatch" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^hard starting snort$"
        ] }
      }
    } else if [syslog][identifier] == "snort" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Alert" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^S5: Pruned session from cache that was using %{INT} bytes \(stale/timeout\). %{IP_SRC} %{PORT_SRC} --> %{IP_DST} %{PORT_DST} \(0\) : LWstate %{BASE16NUM} LWFlags %{BASE16NUM}$",
          "^S5: Session exceeded configured max (bytes|segs) to queue %{INT} using %{INT} (bytes|segs) \((client|server) queue\)\. %{IP_SRC} %{PORT_SRC} --> %{IP_DST} %{PORT_DST} \(0\) : LWstate %{BASE16NUM} LWFlags %{BASE16NUM}$",
          "^%{SNORTMSG}$"
        ] }
      }
    } else if [syslog][identifier] == "sudo" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^clearsync : TTY=unknown ; PWD=/ ; USER=root ; COMMAND=/sbin/service firewall restart$"
        ] }
      }
    } else if [syslog][identifier] == "timesync" {
      grok {
        patterns_dir => [ "/etc/logstash/patterns.d/" ]
        add_tag => [ "Known Message", "Benign" ]
        tag_on_failure => [ ]
        match => { "message" => [
          "^synchronizing (with ntpdate|hardware clock)$"
        ] }
      }
    }
  } 
}
